# 구조체 + 스트림 방식

- 구조체는 불변성으로 인해 자기 자신에 새 인스턴스를 할당할 수 없다.
- Self를 리턴하면서 스트림 방식으로 사용하고 싶어도, 원본을 변경하고 반환하는 스트림 방식은 사용이 불가하다.
- 인스턴스를 가변인 변수에 담아두면 변경이 된 self를 반환할 수 있다.
  - 하지만 첫 반환 이후에는 불변성으로 다시 체이닝을 하는 것이 불가하다.
  - 리턴된 그 self도 원본의 복사본에 해당한다.
- 구조체에서 스트림 방식으로 함수를 사용하고 싶다면, 원본을 유지하고 새로운 인스턴스에 변경을 적용한 다음 반환하는 방식으로 구현해야한다.

# Swift Concurrency

Swift 5.5부터 사용 가능한 동시성 프로그래밍 기술이다.

기존 GCD에서 발생하는 스레드 차단 방식이 아닌, 더 효율적인 방식으로 비동기 코드의 시점 관리를 도와준다.

전반적으로 비동기 작업 수행, 시점 관리, UI 업데이트 차단 방지와 같이 개발자가 비동기 작업을 관리하면서 신경써야하는 다양한 부분이 자연스럽게 처리될 수 있도록 도와주는 기능들로 이루어져있다. 

## async

```swift
func asyncTask() async { }
```

비동기로 작동하는 함수에 대해 `async` 키워드로 명시할 수 있다.

함수가 비동기 작업을 수행할 수 있고 `await` 키워드를 사용해서 다른 비동기 함수를 호출할 수 있음을 나타낸다.

하지만 `async` 키워드 자체가 함수 내의 모든 작업을 자동으로 비동기로 만들어주는 것은 아니다.

`async` 함수를 호출할 때, 호출한 스레드에서 이어서 실행되지 않는다. 정확히는 호출한 스레드와 관계없이 실행될 수 있다.

`async` 함수 내에서 실행되는 작업은 Swift 동시성 모델에서 관리되고, 필요에 따라 다른 스레드로 전환될 수 있다.

## await

```swift
await asyncTask()
```

`async` 함수를 호출할 때 사용한다.

`await`을 사용하면 기존의 `completion` 방식과 다르게 비동기 작업도 동기 작업처럼 코드를 작성할 수 있어서 가독성이 크게 좋아진다.

### await의 비동기 작업 시점 관리

`await`으로 `async` 함수를 호출하면, 해당 작업이 완료될 때까지 코드의 실행 흐름을 멈추고 완료를 기다린다.

하지만 GCD의 `sync`와 다르게, 스레드를 차단하는 방식은 아니다.

### await의 스레드 관리

`await`로 인해 코드 실행이 중단되면, 메인 스레드 컨트롤이 이벤트 루프로 반환되어서 다른 UI 이벤트를 처리할 수 있다.

이로 인해서 UI 응답성이 유지될 수 있는 것!!

예를 들어 `await`으로 비동기 함수를 호출했을 때, 뷰 로딩과 같은 작업이 이미 이벤트 큐에 존재한다면 처리가 가능하다.

물론 `await`으로 호출한 지점 이후에 실행되는 코드들은 처리되지 않는다.

## Task

일반적인 동기 함수에서 다른 `async` 함수를 호출하려고 하면, 동시성 컨텍스트에서 호출해달라면서 에러가 발생한다.

아 ㅎㅎ 동시성 컨텍스트에서 해주면 되는구나~ 동시성 컨텍스트 알지 ㅎㅎ 하면서 `global.async` 스코프로 감싸주어도 에러는 사라지지 않는다.

`global.async`도 동시성 컨텍스트는 맞지만 Swift Concurrency와는 호환이 되지 않기 때문에, 다른 방식으로 동시성 컨텍스트를 제공해주어야 한다.

첫 번째 방법은 호출하고 있는 함수(지금 여기)에 `async`를 추가해서 비동기 함수로 만들어주는 것이다.

하지만 이 방법은 전체 함수를 비동기로 만들어버리는 단점이 있다.

이런 상황에서 `Task`를 사용할 수 있다.

함수를 `async`로 변경하지 않고 내부에서 비동기 작업을 수행하고 싶을 때, `Task` { }를 열고 내부에 비동기 작업을 작성할 수 있다.

```swift
func syncFunction() {
  print("A")
  
  Task {
    await asyncFunction()
  }
  
  print("B")
}
```

위와 같이 동기 함수더라도, `Task`를 사용해서 특정 코드 블록만 비동기로 작동할 수 있게 해주는 것이다.

### Task 사용 시 주의사항

위의 코드 예시를 보면 `global.async`와 같은 문제점이 바로 보일텐데, 동작이 순서대로 수행되지 않는다는 것이다.

```swift
func syncFunction() {
  print("A")
  
  Task {
    await asyncFunction()
    print("B")
  }
  
  print("C")
}
```

위와 같은 코드에서 `Task` 블록은 `syncFunction`과 독립적으로 수행된다.

Task 블록이 호출 스레드의 실행 흐름을 막지 않고 병렬로 실행되기 때문에 높은 확률로 "C"가 먼저 출력된다.

```swift
func syncFunction() async {
  print("A")
  
  await Task {
    await asyncFunction()
    print("B")
  }
  
  print("C")
}
```

만약 `Task` 블록으로 실행 흐름을 멈추고 싶다면, `Task` 앞에 `await`을 붙일 수 있다.

이러면 `Task` 내부 작업이 모두 완료된 후에 `print("C")`가 수행될 것이다.

하지만 `await`을 함수 내부에서 사용했기 때문에, 당연히 이 함수도 비동기 함수로 만들어주어야 한다.

### 클로저와의 조합

위에서 `async` 함수를 호출할 때, 호출하고 있는 동기 함수를 `async`로 만들어서 `Task` 없이 호출할 수 있다고 했는데, 만약 여기가 함수가 아니라 클로저면 어떻게 할까?

사실 클로저도 `async` 키워드를 선언할 때 추가할 수 있다.

```swift
let myAsyncClosure: () async -> Void = {
    await someAsyncFunction()
}
```

하지만 만약 애플 혹은 라이브러리에서 제공하는 동기 API에 `async` 클로저를 선언해야한다면?

 내가 만든 함수가 아니라면 async를 선언부에 작성할 수 없기 때문에, `Task`를 더 유용하게 쓸 수 있다.

## 여러 비동기 작업을 실행한다면?

### CASE 1. 비동기 작업들을 동시에 수행하기

위에서 본 내용을 토대로 생각해보면, `Task` 내부는 동기적으로 작동하지만 `Task` 블록 자체는 `await Task`로 코드 실행 흐름을 막지 않는다면 다음 코드 라인으로 넘어가서 실행된다.

만약 3개의 네트워크 요청을 동시에 수행하고 싶다면 아래와 같이 여러 `Task` 블록을 만들면 된다.

```swift
func syncFunction() {
  Task {
    await asyncFunction()
  }

  Task {
    await asyncFunction2()
  }

  Task {
    await asyncFunction3()
  }
}
```

위 함수는 각 `Task`를 만날 때마다 별도의 스레드에 네트워크 요청 작업을 전달하고 이어서 다음 `Task` 블록을 만나러 갈 것이다.

### CASE 2. 이전 요청의 결과를 사용해서 다음 요청을 진행해야 할 때

자주 있는 케이스 중에 특정 작업의 응답을 기다렸다가, 그 데이터를 활용해서 다음 요청을 하는 경우도 있다.

기존에 `completion`으로 해결해야 할때 `completion` 안에 `completion` 안에 `completion`... 같은 코드를 작성하게 만드는 케이스기도 하다.

```swift
func syncFunction() {
  Task {
    let url = await getURL()
    let image = await getImage(url: url)
    updateImage(image: image)
  }
}
```

위에서 계속 설명한 것처럼 `await`을 비동기 함수를 호출해도 코드 실행 흐름을 중단시킬 수 있기 때문에, 이처럼 순차적인 비동기 함수 실행이 필요할 때 사용 가능하다.

### CASE 3. 동시에 실행은 하지만, 모든 응답이 완료될 때를 알아야 한다면?

아까 CASE 1에서는 여러 비동기 작업을 동시에 수행은 하지만, 각 비동기 작업이 끝나는 시점을 특정하거나 활용할 수는 없었다.

만약 비동기 작업을 병렬로 처리는 하지만, 모든 응답이 모였을 때 이 데이터를 가지고 추가 작업을 해야한다면?

이 때 `async let`을 활용할 수 있다.

```swift
func performConcurrentTasks() async {
  async let result1 = asyncFunction1()
  async let result2 = asyncFunction2()
  
  let (response1, response2) = await (result1, result2)
  
  print("Done")
}
```

이전에 `async` 함수를 호출할 때와 달라진 점이 보이는데, `await`으로 함수를 호출하지 않고, 대신 `let` 앞에 `async` 키워드가 추가되었다.

위 함수를 실행하면 `asyncFunction1`, `asyncFunction2`는 마치 별도의 `Task` 블록에 있는 것처럼 각각 동시에 병렬로 작업이 시작된다.

그리고 그 이후에 작업의 응답이 필요한 곳에서 `await`을 만나면, 이 시점에 코드 실행 흐름이 멈추고 필요한 모든 응답들을 기다린다.

그 이후에 마지막으로 "Done"이 수행된다.

이처럼 병렬 작업이 필요한 곳에서는 동시에 수행되도록 하고, 결과가 필요한 시점에 실행 흐름을 멈출 수 있어서 병렬 작업과 시점 관리를 모두 해결할 수 있다.


## await의 작동 원리

이전까지는 사용법과 사용 예시 시나리오를 위주로 알아봤다.

그래도 내부 작동 원리를 조금은 이해하고 가면 좋을 것 같아서 간단하게 정리해보았다. 아마 딥하게 들어가면 엄청 어렵겠지...

처음에 `await`을 설명할 때 얘기한 것처럼, `await`으로 비동기 함수를 호출하면 해당 작업이 완료될 때까지 코드 실행 흐름이 일시적으로 중단된다.

하지만 GCD의 `sync`처럼 스레드를 차단해서 강제로 멈추는 것이 아니라, 해당 스레드로 다른 작업을 수행할 수 있게 해서 더 효율적으로 스레드를 관리할 수 있다고 했다.

모든 `async` 함수는 Task 내부에서 실행된다. (위에 코드에서 사용하던 `Task { }`블록과 다른 추상화된 객체 이름임)

비동기 작업들은 작업 스케줄러가 관리하면서 CPU 코어와 스레드를 효율적으로 활용하여 작업들을 실행해준다.

`async` 함수 내부에서 실행되는 네트워크 요청, 파일 I/O 같은 작업은 백그라운드에서 진행되는데, 작업이 완료되면 작업 결과와 함께 작업 완료! 이벤트가 이벤트 루프에 등록된다.

그러면 시스템이 완료 이벤트를 감지하고, 아까 `await`으로 실행 흐름을 막은 지점에서 작업을 재개할 수 있도록 스케줄링 해준다.

이 때 스케줄러가 작업 재개를 위해 적절한 스레드를 할당해주지만, 그 스레드가 `await` 이전까지 여기서 열심히 일을 하던 그 스레드라는 보장은 없다.
